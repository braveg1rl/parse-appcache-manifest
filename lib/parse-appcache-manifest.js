// Generated by CoffeeScript 1.6.3
(function() {
  module.exports = function(manifest, opts) {
    var currentSection, entries, firstLine, foundSection, handleEntryFrom, line, lines, mode, tokens, _i, _j, _len, _len1;
    if (opts == null) {
      opts = {};
    }
    lines = manifest.split(/\r\n|\r|\n/);
    firstLine = lines.shift().trim();
    if (firstLine.indexOf('CACHE MANIFEST') !== 0) {
      throw new Error("Invalid cache manifest header: " + firstLine);
    }
    currentSection = 'CACHE';
    if (opts.tokenize) {
      mode = 'explicit';
      entries = [
        {
          type: 'magic signature',
          value: 'CACHE MANIFEST'
        }
      ];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        line = line.trim();
        if (!line.length) {
          entries.push({
            type: 'newline'
          });
        } else if (line.indexOf('#') === 0) {
          entries.push({
            type: 'comment',
            value: line.substring(1)
          });
        } else if (['CACHE:', 'FALLBACK:', 'NETWORK:', 'SETTINGS:'].indexOf(line) >= 0) {
          mode = line.substring(0, line.length - 1);
          entries.push({
            type: 'mode',
            value: mode
          });
        } else if (line.indexOf(':') === (line.length - 1)) {
          mode = 'unknown';
          entries.push({
            type: 'mode',
            value: mode,
            raw: line
          });
        } else {
          tokens = line.split(/[ ]+/);
          entries.push({
            type: 'data',
            tokens: tokens
          });
        }
      }
    } else {
      entries = {
        cache: [],
        network: [],
        fallback: {},
        settings: {}
      };
      handleEntryFrom = {
        CACHE: function(line) {
          return entries.cache.push(line);
        },
        NETWORK: function(line) {
          return entries.network.push(line);
        },
        FALLBACK: function(line) {
          var bits;
          bits = line.split(" ");
          return entries.fallback[bits[0]] = bits[1];
        }
      };
      for (_j = 0, _len1 = lines.length; _j < _len1; _j++) {
        line = lines[_j];
        line = line.trim();
        if (foundSection = findSection(line)) {
          currentSection = foundSection;
          continue;
        }
        if (line === "") {
          continue;
        }
        if (line[0] === "#") {
          continue;
        }
        handleEntryFrom[currentSection](line);
      }
    }
    return entries;
  };

}).call(this);
